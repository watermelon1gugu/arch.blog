---
title: JVM-memory-model
date: 2018-08-08 01:52:01
tags: 
	- JVM
	- memory
	- model
---

JVM是Java开发的必备基础之一.在Java中JVM具有垃圾回收的机制,承担了对象的创建和释放内存的工作,使得开发者不需要像在C++里一样需要手动申请内存然后释放内存.否则会出现对象已经不再使用内存,内存空间却仍被占用的情况.

<!--*more*-->

# 内存模型

![JVM内存模型](https://user-images.githubusercontent.com/25349066/42741821-2c13b636-88e8-11e8-93c2-c1f1a831a724.png)

以上为jvm内存模型,其中最主要的是java栈与java堆,其中里李存放各种对象实例而栈里存放最基本的数据类型和引用.

这样做带来的好处是:

- 栈存储了处理逻辑,堆存储了具体的数据,使得结构更为清晰.
- 栈与堆分离,使得堆可以被多个栈共享.
- 栈保存了上下文的信息,因此只能向上增长,而堆是动态分配.

栈的大小可以通过-Xss设置,如果栈空间不足,会引起StackOverflowError异常.

## JAVA堆

在大多数情况下,Java堆是jvm所管理的内存中最大的一块.Java堆是被所有线程共享的一块内存区域,在虚拟机启动时创建.其唯一的作用就是存放对象实例,几乎所有对象实例都在这里分配内存.以下是Java虚拟机规范中的描述

> 所有的对象实例以及数组都要在堆上分配，但是随着JIT 编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。

Java堆是垃圾收集器管理的主要区域.由于现在收集器基本都说是采用分代收集算法,所以Java堆还可细分为新生代与老年代.从内存分配的角度看,线程共享的Java堆可能划分处多个线程私有的TLB.但无论如果划分,都与存放内容无关,无论在那个区域,存放内容都是对象实例,细分的目的是为了更好地回收内存与分配内存.

根据Java虚拟机规范的规定,Java堆可以处于物理上不连续的内存空间中,只要逻辑上连续即可.在实现时,既可以实现成固定大小的,也可以是可扩展的,目前主流的虚拟机都是按照可扩展来实现的(通过-Xmx和-Xms控制).若堆空间不足且无法再扩展,将会抛出OutOfMemoryError异常.

## JAVA栈

Java虚拟机栈是线程私有的,它的生命周期与线程相同.Java虚拟机栈主要描述的是Java方法执行的内存模型:每个方法被执行的时候都会同时创建一个**栈帧**用于存储局部变量表,操作数,动态链接,方法出口等信息.每个方法被调用直至执行完成的过程,就对应者一个栈帧在虚拟机中从入栈到出栈的过程.

常说的JAVA栈主要是指JAVA虚拟机栈中的局部变量表部分,局部变量表存放了编译期可知的各种基本数据类型(boolean,byte,char,short,int,float,long,double),对象引用(reference类型,不等同于对象本身,根据不同的虚拟机实现,它可能是一个指向对象起始地址的引用指针,也可能指向一个代表对象的句柄或者其他与此对象相关的位置)和returnAddress类型(指向了一条字节码指令的地址).其中64位长度的long和double类型数据会占用2个局部变量空间(Slot).局部变量表所需的内存空间在编译期间完成分配,当进入一个方法时,这个方法需要在帧中分配多大的局部变量空间是完全确定的,在方法运行期间不会改变局部变量表的大小.

在Java虚拟机规范中,对这个区域规定了两种异常状况:

1. 如果线程请求的栈深度大于虚拟机所允许的深度,将抛出StackOverflowError(爆栈)异常.
2. 如果虚拟机栈可以动态扩展(当前大部分的java虚拟机都可动态扩展),当扩展时无法申请到足够的内存时将抛出OutOfMemoryError异常.

## 本地方法栈

本地方法栈与虚拟机栈所发挥的作用是非常相似的,其区别在于虚拟机栈为虚拟机执行Java方法服务,而本地方法栈则是为虚拟机使用到的Native方法(Java调用非Java代码的接口,一个Native方法是一个Java方法的非Java语言实现)服务.虚拟机规范中对本地方法栈的方法使用的语言,使用方法与数据结构并没有强制规定,因此具体的虚拟机可以自由实现它.其余与Java虚拟机栈基本一样.

## 方法区

方法区与Java堆一样,是各个线程共享的内存区域,它用来存储已被虚拟机加载的类信息,常量,静态变量,即时编译器编译后的代码等数据.虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分,但是它却有一个别名叫做Non-heap(非堆),目的应该是与Java堆区分开来.

Java虚拟机规范对于这个区域的限制非常宽松,除了和Java堆一样不需要连续的内存和可以选择固定大小或者扩展外,还可以选择不实现垃圾收集.相对而言,垃圾收集行为在这个区域是比较少出现的.这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载,一般来说这个区域的回收效果难以令人满意,尤其是类型的卸载,条件非常苛刻.但这部分区域的回收确实是有必要的.

当方法区无法满足内存分配需求时,将抛出OutOfMemoryError异常.

## 运行时常量池

运行时常量池是方法区的一部分.Class文件中除了有类的版本,字段,方法,接口等描述信息外,还有一项信息是常量池,用于存放编译期生成的各种字面量和符号引用,这部分内容将在类加载后存放到方法区的运行时常量池中.

对于运行时常量池,java虚拟机规范并没有做任何细节的要求,不同的虚拟机可以安装自己的需要来实现这个内存区域.不过,一般来说,除了保存Class文件中描述的符号引用外,还会把翻译出来的直接引用也存储在运行时常量池中.

运行时常量池相对于Class文件池的另外一个重要特性是具备动态性,Java语言并不要求常量一定只能在编译器产生,也就是并非预置入Class文件中常量池的内容才能进入方法池,运行期间也可能将新的常量放入池中,这种特性被开发人员利用得比较多的便是**String类的intern()方法**.

当常量池无法再申请到内存时会抛出OutOfMemoryError异常.

## 程序计数器

程序计数器是一块较小的内存空间,它的作用可以看做是当前线程所执行的字节码的行号指示器.在虚拟机的概念模型中(仅概念,各种虚拟机可能会通过一些更高效的方式区实现),字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令,分支,循环,跳转,异常处理,线程恢复等基础功能都需要依赖这个计数器来完成.

由于Java虚拟机的多线程是通过**线程轮流切换并分配处理器执行时间**的方式来实现的,在任何一个确定的时刻,一个处理器(对于多核处理器来说是一个内核)只会执行一条线程中的指令.因此,为了线程切换后能恢复到正确的执行位置,每条线程都需要有一个独立的程序计数器,各条线程的计数器互不影响,独立存储,我们称这类内存区域为”线程私有”的内存.

如果线程这种执行的是一个Java方法,这个计数器记录的是正在执行的虚拟机字节码指令的地址.如果正在执行的是Native方法,这个计数器值为空(Undefined).

此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域.

## 直接内存

直接内存并不是虚拟机运行时数据区的一部分,也不是Java虚拟机规范中定义的内存区域,但是这部分内存也被频繁地使用,而且页可能导致OutOfMemoryError异常出现,所以我们放到这里一起讲解.
在JDK1.4中新加入了**NIO**(New Input/Output)类,引入了一种基于通道(Channel)与缓冲区(Buffer)的I/O方式,它可以使用Native函数库直接分配库外内存,然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作.这样能在一些场景中显著提高性能,因为避免了在Java堆和Native堆中来回复制数据.
显然,本机直接内存的分配不会受到Java堆大小的限制,但是,既然是内存,肯定还是会受到本机总内存的大小以及处理器寻址空间的限制.服务器管理员配置虚拟机参数时,一般会根据实际内存设置-Xmx等参数信息,但是经常会忽略掉直接内存,使得各个内存区域的总和大于物理内存限制(包括物理上的操作系统级的限制),从而导致动态扩展时出现OutOfMemoryError异常.

# JAVA对象访问

以以下代码为例

```
Object obj = new Object();
```

若这句代码出现在方法体中,则”Object obj”这部分的语义将会反映到Java栈的本地变量表中,作为一个reference类型数据出现.而”new Object()”这部分的语义将会反映到Java堆中,**形成一块存储了Object类型所有实例数据值**(Instance Data,对象中各个实例字段的数据)的结构化内存,根据具体类型以及虚拟机实现的对象内存布局的不同,这块内存的长度是不固定的.另外,在Java堆中还必须包含能查找到此对象类型数据(如对象类型,父类,实现的接口,方法等)的地址信息,这些类型数据则存储在方法区中.

由于reference类型在Java虚拟机规范里面只规定了一个指向对象的引用,并没有定义这个引用应该通过哪种方式区定位,以及访问到Java堆中的对象的具体位置,因此不同虚拟机实现的对象访问方式会有所不同,主流的访问方式有两种:使用句柄访问和直接指针.

## 使用句柄访问

如果使用句柄访问方式,Java堆中将会划分出一块内存来作为句柄池,reference中存储的就是对象的句柄地址,而句柄中包含了**对象实例数据和类型数据各自的具体地址信息**.

**![句柄访问](https://user-images.githubusercontent.com/25349066/42831463-fb63188a-8a20-11e8-8339-dd45a7e3bb27.png)**

## 使用直接指针访问

如果使用直接指针访问方式,Java堆对象的布局中,就必须设计如何放置访问类型数据的相关信息,reference中直接存储的就是对象地址.

![接指针访问](https://user-images.githubusercontent.com/25349066/42832184-068c590e-8a23-11e8-844c-3021088501ab.png)

## 对比

这两种对象的访问方式各有优势,使用句柄访问方式的最大好处就是reference中存储的是稳定的句柄地址,在对象被移动(垃圾收集时移动对象是非常普遍的行为)时只会改变句柄中的实例对象指针,而reference本身不需要被修改.

使用直接指针访问方式的最大好处就是速度更快,它节省了一次指针定位的时间开销,由于对象的访问在Java中非常频繁,因此这类开销积少成多后也是一项非常客观的执行成本.